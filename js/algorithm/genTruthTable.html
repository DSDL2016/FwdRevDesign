<html>
<head>
<title></title>
</head>
<script src="qmSimplify.js"></script> 
<script>

/**
  * For a specfic index in the state string
  * fsm {'10': [{next: '00', out: '0'}, {next: '10', out: '0'}],  ....}
  * => ["101","011"]
  */
function index2truthTable(index, fsm) {
  var arr = [];
  for (let state in fsm) {
    for (let input = 0; input <= 1; input++) {
      if (fsm[state][input].next[index] == '1')
        arr.push(state + input);
    }
  }
  return arr;
}

/**
  * fsm {'10': [{next: '00', out: '0'}, {next: '10', out: '0'}],  ....}
  * => [["101","011"],["001"]]
  */
function fsm2stateTruthTable(fsm, totalBit) {
  var arr = [];
  for (let i = 0; i < totalBit; i++)
    arr.push(index2truthTable(i, fsm));
  return arr;
}

function fsm2outputTruthTable(fsm) {
  var arr = [];
  for (let state in fsm) {
    for (let input = 0; input <= 1; input++) {
      if (fsm[state][input].out == '1')
        arr.push(state + input);
    }
  }
  return arr;
}

function truthTable2Schematic(truthTable, outputIndex) {
  // output and AND gate
  schematic = [];
  if (outputIndex == -1) {
    schematic.push({type: 'output'});
    schematic.push({type: 'and', out:[[{id: 0, port: 0}]]});
  } else {
    schematic.push({type: 'and', out:[[{id: 2 * outputIndex + 1, port: 0}]]});
  }

  // create all input pin
  for (let i = 0; i < totalBit; i++) {
    schematic.push({type: 'dff ' + i, out: [[{id: schematic.length + 1, port: 0}]]});
    schematic.push({type: 'not', out: [[]]});
  }

  schematic.push({type: 'dff ' + totalBit, out: [[{id: schematic.length + 1, port: 0}]]});
  schematic.push({type: 'not', out: [[]]});

  // traverse each sum of sum-of-pruducts
  for (let i = 0; i < truthTable.length; i++) {
    schematic.push({type: 'or', out: [[{id: (outputIndex == -1) ? 1 : 0, port: i}]]});
    var orGateIndex = schematic.length - 1;
    for (let j = 0; j < truthTable[i].length; j++) {
      var inputPort = schematic.find(function(x) { return x.type == ("dff " + j)});
      var index = schematic.indexOf(inputPort);
      if (1 == truthTable[i][j])
        schematic[index].out[0].push({id: orGateIndex, port: j});
      else
        schematic[index + 1].out[0].push({id: orGateIndex, port: j});
    }
  }
  return schematic;
}













let fsm = {
  '10': [{next: '00', out: '0'}, {next: '10', out: '0'}],
  '00': [{next: '00', out: '0'}, {next: '01', out: '0'}],
  '01': [{next: '00', out: '1'}, {next: '10', out: '1'}]
};

var totalBit = 2;
var stateTruthTables = fsm2stateTruthTable(fsm, totalBit);
var outputTruthTable = fsm2outputTruthTable(fsm);

outputTruthTable = qmSimplify(outputTruthTable);
for (let i = 0; i < stateTruthTables.length; i++)
  stateTruthTables[i] = qmSimplify(stateTruthTables[i]);

document.write(JSON.stringify(stateTruthTables) + "<hr>");
document.write(JSON.stringify(outputTruthTable) + "<hr>");

// TODO: refactor schematic
var schematic = truthTable2Schematic(outputTruthTable, -1);

// print the result
for (let each in schematic) 
  document.write(JSON.stringify(schematic[each]) + "<br>");
document.write("<br>");

var test = truthTable2Schematic(stateTruthTables[0], 0);
for (let each in test) 
  document.write(JSON.stringify(test[each]) + "<br>");

</script>
<body>
</body>
</html> 
